#!/usr/bin/env bash
#
# Summary: Display help for a command
#
# Usage: jlenv [<opts>] help [--usage] COMMAND
#
# Parses and displays help contents from a command's source file.
#
# A command is considered documented if it starts with a comment block
# that has a `Summary:' or `Usage:' section. Usage instructions can
# span multiple lines as long as subsequent lines are indented.
# The remainder of the comment block is displayed as extended
# documentation.

# Import functions shared between jlenv scripts and plugins.
# Function specific to each jlenv-<command> script are:
# - script_usage
# - main "$@" which calls
#    1. script_init "$@"
#    2. script_defaults
#    3. parse_cmds "$@"
# - `jlevn_<command>` holds functional logic and is called by `parse_cmds`
source jlenv-shared

[ -n "$JLENV_DEBUG" ] && set -x

# Provide jlenv completions
if [ "$1" = "--complete" ]; then
  echo --usage
  exec jlenv-commands
fi

command_path() {
  local command="$1"
  command -v jlenv-"$command" || command -v jlenv-sh-"$command" || true
}

extract_initial_comment_block() {
  sed -ne "
    /^#/ !{
      q
    }

    s/^#$/# /

    /^# / {
      s/^# //
      p
    }
  "
}

collect_documentation() {
  $(type -p gawk awk | head -1) '
    /^Summary:/ {
      summary = substr($0, 10)
      next
    }

    /^Usage:/ {
      reading_usage = 1
      usage = usage "\n" $0
      next
    }

    /^( *$|       )/ && reading_usage {
      usage = usage "\n" $0
      next
    }

    {
      reading_usage = 0
      help = help "\n" $0
    }

    function escape(str) {
      gsub(/[`\\$"]/, "\\\\&", str)
      return str
    }

    function trim(str) {
      sub(/^\n*/, "", str)
      sub(/\n*$/, "", str)
      return str
    }

    END {
      if (usage || summary) {
        print "summary=\"" escape(summary) "\""
        print "usage=\"" escape(trim(usage)) "\""
        print "help=\"" escape(trim(help)) "\""
      }
    }
  '
}

documentation_for() {
  local filename="$(command_path "$1")"
  if [ -n "${filename}" ]; then
    extract_initial_comment_block < "$filename" | collect_documentation
  fi
}

print_summary() {
  local command="$1"
  local summary usage help
  eval "$(documentation_for "$command")"

  if [ -n "$summary" ]; then
    printf "   %-9s   %s\n" "${command}" "${summary}"
  fi
}

print_summaries() {
  for command; do
    print_summary "$command"
  done
}

print_help() {
  local command="$1"
  local summary usage help
  eval "$(documentation_for "$command")"
  [ -n "$help" ] || help="$summary"

  if [ -n "$usage" ] || [ -n "$summary" ]; then
    if [ -n "$usage" ]; then
      echo "${usage}"
    else
      echo -n "Usage: jlenv [<opts>] ${command}"
    fi
    if [ -n "$help" ]; then
      echo
      echo -n "${help}"
    fi
  else
    echo "Sorry, this command isn't documented yet." >&2
    return 1
  fi
}

print_usage() {
  local command="$1"
  local summary usage help
  eval "$(documentation_for "$command")"
  [ -z "$usage" ] || echo "${usage}"
}

# DESC: Script jlenv initialisation
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: $<JLENV-CMD>_ORIG_CWD: The working directory when the script was run
#       $<JLENV-CMD>_PATH: The full path to the script (folder & name)
#       $<JLENV-CMD>_DIR: The directory path of the script
#       $<JLENV-CMD>_NAME: The file name of the script
#       $<JLENV-CMD>_ARGS: The original cmdeters provided to the script
# NOTE: $<JLENV-CMD>_PATH only contains the path that was used to call the script
#       and will not resolve any symlinks which may be present in the path.
#       The same applies to the $<JLENV-CMD>_DIR and $<JLENV-CMD>_NAME variables.
function script_init() {
    # Useful paths: Global, export, readonly, UPPERCASE, trace
    declare -gxr "JLENV_HELP_ORIG_CWD=$(pwd -P)"
    declare -gxr "JLENV_HELP_PATH=$(resolve_path "${BASH_SOURCE[0]}")"
    declare -gxr "JLENV_HELP_DIR=$(resolve_path "$(dirname "${JLENV_HELP_PATH}")")"
    declare -gxr "JLENV_HELP_NAME=$(basename "${JLENV_HELP_PATH}")"
    declare -gxr "JLENV_HELP_ARGS=$*"
}

# DESC: Full jlenv usage help.
# ARGS: None
# OUTS: Help text.
function script_usage() {
    command jlenv---version
    cat << EOF
Options to jlenv:
     -h|--help                  Displays this help
     -v|--verbose               Displays verbose output
    -nc|--no-colo(u)r           Disables colour output
    -cr|--cron                  Run silently unless we encounter an error

EOF
    command jlenv-help help
}


# DESC: Parameter parser
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: Variables indicating command-line cmdeters and options
function parse_cmds() {
    local cmd
    if [[ $# -eq 0 ]]
    then
      script_usage
      exit 1
    fi
    while [[ $# -gt 0 ]]; do
        cmd="${1}"
        shift
        case ${cmd} in
            -h|--help)
                script_usage
                exit 0
                ;;
            -v|--verbose)
                verbose_setup
                ;;
            -nc|--no-colour|--no-color)
                no_colour=true
                ;;
            -cr|--cron)
                cron=true
                ;;
            *)
                # Add scommand logic here
                ;;
        esac
    done
}

# DESC: Set environment default values.
#       Variables should not be referenced using ${variable:-default}.
#       Variables should not be tested using:
#         1. [ -n "${variable}" ]
#         2. [ -z "${variable}"]
#       Instead test for explicit values: 
#         [[ "${variable}" = "value" ]]
# ARGS: None.
# OUTS: None.
#
function script_defaults() {
  return
}

# DESC: Main control flow
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: None
function main() {
    trap script_trap_err ERR
    trap script_trap_exit EXIT

    script_init "$@"
    script_defaults
    #parse_cmds "$@"
}

#####################################################################
###  Execute
#####################################################################

main "$@"

unset usage
if [ "${1}" = "--usage" ]; then
  usage="1"
  shift
fi

if [ -z "$1" ] || [ "$1" == "jlenv" ]; then
  echo "Usage: jlenv [<opts>] <command> [<args>]"
  [ -z "${usage}" ] || exit
  echo
  echo "Some useful jlenv commands are:"
  print_summaries commands local global shell install uninstall rehash version versions which whence
  echo
  echo "See \$(jlenv help <command>) for information on a specific command."
  echo "For full documentation, see: https://github.com/jlenv/jlenv#readme"
else
  command="$1"
  if [ -n "$(command_path "${command}")" ]; then
    if [ -n "${usage}" ]; then
      print_usage "${command}"
    else
      print_help "${command}"
    fi
  else
    echo "jlenv: no such command \$(${command})" >&2
    exit 1
  fi
fi
