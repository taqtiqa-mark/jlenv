#!/usr/bin/env bash

# A best practices Bash script template with many useful functions. This file
# is suitable for sourcing into other scripts and so only contains functions
# which are unlikely to need modification. It omits the following functions:
# - main()
# - parse_params()
# - script_usage()

# Export each variable/function created or modified.
set -o allexport

unset test_euid

# DESC: Handler for unexpected errors
# ARGS: $1 (optional): Exit code (defaults to 1)
# OUTS: None
function script_trap_err() {
    local exit_code=1

    # Disable the error trap handler to prevent potential recursion
    trap - ERR

    # Consider any further errors non-fatal to ensure we run to completion
    set +o errexit
    set +o pipefail

    # Validate any provided exit code
    if [[ ${1-} =~ ^[0-9]+$ ]]; then
        exit_code="${1}"
    fi

    # Output debug data if in Cron mode
    if [[ -n ${cron-} ]]; then
        # Restore original file output descriptors
        if [[ -n ${script_output-} ]]; then
            exec 1>&3 2>&4
        fi

        # Restore terminal colours
        printf '%b\n' "$ta_none"
        # Print basic debugging information
        printf 'jlenv:  ***** Abnormal termination of script `*****\n'
        printf 'jlenv:  Script Path:            %s\n' "$jlenv_path"
        printf 'jlenv:  Script Parameters:      %s\n' "$jlenv_params"
        printf 'jlenv:  Script Exit Code:       %s\n' "$exit_code"

        # Print the script log if we have it. It's possible we may not if we
        # failed before we even called cron_init(). This can happen if bad
        # parameters were passed to the script so we bailed out very early.
        if [[ -n ${script_output-} ]]; then
            printf 'jlenv:  Script Output:\n\n%s' "$(cat "$script_output")"
        else
            printf 'jlenv:  Script Output:          None (failed before log init)\n'
        fi
    fi

    # Exit with failure status
    exit "${exit_code}"
}


# DESC: Handler for exiting the script
# ARGS: None
# OUTS: None
function script_trap_exit() {
    cd "${jlenv_orig_cwd:-}"

    # Remove Cron mode script log
    if [[ -n ${cron-} && -f ${script_output-} ]]; then
        rm "$script_output"
    fi

    # Remove script execution lock
    if [[ -d ${script_lock-} ]]; then
        rmdir "$script_lock"
    fi

    # Restore terminal colours
    printf '%b' "${ta_none:-}"
}


# DESC: Exit script with the given message
# ARGS: $1 (required): Message to print on exit
#       $2 (optional): Exit code (defaults to 0)
# OUTS: None
function script_exit() {
    if [[ $# -eq 1 ]]; then
        printf 'jlenv:  %s\n' "${1}"
        exit 0
    fi

    if [[ ${2-} =~ ^[0-9]+$ ]]; then
        printf 'jlenv:  %b\n' "${1}"
        # If we've been provided a non-zero exit code run the error trap
        if [[ $2 -ne 0 ]]; then
            script_trap_err "${2}"
        else
            exit 0
        fi
    fi

    script_exit "Missing required argument to \$(script_exit)" 2
}

# DESC: Generic script initialisation
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: $orig_`cwd: The current working directory when the script was run
#       $jlenv_path: The full path to the script
#       $jlenv_dirname: The directory path of the script
#       $jlenv_name: The file name of the script
#       $jlenv_params: The original parameters provided to the script
#       $ta_no`ne: The ANSI control code to reset all text attributes
# NOTE: $jlenv_path only contains the path that was used to call the script
#       and will not resolve any symlinks which may be present in the path.
#       You can use a tool like realpath to obtain the "true" path. The same
#       caveat applies to both the $jlenv_dirname and $jlenv_name variables.
function script_init() {
    # Useful paths
    readonly jlenv_orig_cwd="$(pwd -P)"
    readonly jlenv_path="$(resolve_path "${BASH_SOURCE[0]}")"
    readonly jlenv_dirname="$(dirname "$jlenv_path")"
    readonly jlenv_name="$(basename "$jlenv_path")"
    readonly jlenv_params="$*"

    # Important to always set as we use it in the exit handler
    readonly ta_none="$(tput sgr0 2> /dev/null || true)"
}


# DESC: Initialise colour variables
# ARGS: None
# OUTS: Read-only variables with ANSI control codes
# NOTE: If --no-colour was set the variables will be empty
function colour_init() {
    if [[ -z ${no_colour-} ]]; then
        # Text attributes
        readonly ta_bold="$(tput bold 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_uscore="$(tput smul 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_blink="$(tput blink 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_reverse="$(tput rev 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_conceal="$(tput invis 2> /dev/null || true)"
        printf '%b' "$ta_none"

        # Foreground codes
        readonly fg_black="$(tput setaf 0 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_blue="$(tput setaf 4 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_cyan="$(tput setaf 6 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_green="$(tput setaf 2 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_magenta="$(tput setaf 5 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_red="$(tput setaf 1 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_white="$(tput setaf 7 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_yellow="$(tput setaf 3 2> /dev/null || true)"
        printf '%b' "$ta_none"

        # Background codes
        readonly bg_black="$(tput setab 0 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_blue="$(tput setab 4 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_cyan="$(tput setab 6 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_green="$(tput setab 2 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_magenta="$(tput setab 5 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_red="$(tput setab 1 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_white="$(tput setab 7 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_yellow="$(tput setab 3 2> /dev/null || true)"
        printf '%b' "$ta_none"
    else
        # Text attributes
        readonly ta_bold=''
        readonly ta_uscore=''
        readonly ta_blink=''
        readonly ta_reverse=''
        readonly ta_conceal=''

        # Foreground codes
        readonly fg_black=''
        readonly fg_blue=''
        readonly fg_cyan=''
        readonly fg_green=''
        readonly fg_magenta=''
        readonly fg_red=''
        readonly fg_white=''
        readonly fg_yellow=''

        # Background codes
        readonly bg_black=''
        readonly bg_blue=''
        readonly bg_cyan=''
        readonly bg_green=''
        readonly bg_magenta=''
        readonly bg_red=''
        readonly bg_white=''
        readonly bg_yellow=''
    fi
}


# DESC: Convert a hex color value to a (nearish) 0-255 color index.
# ARGS: $1 (required): Hexadecimal value
# OUTS: 0-255 color index
# NOTE: The input value requirement is not enforced.
# 
#   Conversion   0-255
# -------------- -----
# fromhex 002b36   016
# fromhex 073642   016
# fromhex 586e75   060
# fromhex 657b83   066
# fromhex 839496   102
# fromhex 93a1a1   109
# fromhex eee8d5   224
# fromhex fdf6e3   230
# fromhex b58900   136
# fromhex cb4b16   166
# fromhex dc322f   160
# fromhex d33682   162
# fromhex 6c71c4   062
# fromhex 268bd2   032
# fromhex 2aa198   036
# fromhex 859900   100
script_hex_to_255(){
    hex=${1#"#"}
    r=$(printf '0x%0.2s' "$hex")
    g=$(printf '0x%0.2s' ${hex#??})
    b=$(printf '0x%0.2s' ${hex#????})
    printf '%03d' "$(( (r<75?0:(r-35)/40)*6*6 + 
                       (g<75?0:(g-35)/40)*6   +
                       (b<75?0:(b-35)/40)     + 16 ))"
}

# DESC: Initialise colour variables
# ARGS: None
# OUTS: Read-only variables with ANSI control codes
# NOTE: If --no-colour was set the variables will be empty
#
#
# SOLARIZED HEX     0-255 16/8 TERMCOL  XTERM/HEX   L*A*B      RGB         HSB
# --------- ------- ----- ---- -------  ----------- ---------- ----------- -----------
# base03    #002b36   016  8/4 brblack  234 #1c1c1c 15 -12 -12   0  43  54 193 100  21
# base02    #073642   016  0/4 black    235 #262626 20 -12 -12   7  54  66 192  90  26
# base01    #586e75   060 10/7 brgreen  240 #585858 45 -07 -07  88 110 117 194  25  46
# base00    #657b83   066 11/7 bryellow 241 #626262 50 -07 -07 101 123 131 195  23  51
# base0     #839496   102 12/6 brblue   244 #808080 60 -06 -03 131 148 150 186  13  59
# base1     #93a1a1   109 14/4 brcyan   245 #8a8a8a 65 -05 -02 147 161 161 180   9  63
# base2     #eee8d5   224  7/7 white    254 #e4e4e4 92 -00  10 238 232 213  44  11  93
# base3     #fdf6e3   230 15/7 brwhite  230 #ffffd7 97  00  10 253 246 227  44  10  99
# yellow    #b58900   136  3/3 yellow   136 #af8700 60  10  65 181 137   0  45 100  71
# orange    #cb4b16   166  9/3 brred    166 #d75f00 50  50  55 203  75  22  18  89  80
# red       #dc322f   160  1/1 red      160 #d70000 50  65  45 220  50  47   1  79  86
# magenta   #d33682   162  5/5 magenta  125 #af005f 50  65 -05 211  54 130 331  74  83
# violet    #6c71c4   062 13/5 brmagenta 61 #5f5faf 50  15 -45 108 113 196 237  45  77
# blue      #268bd2   032  4/4 blue      33 #0087ff 55 -10 -45  38 139 210 205  82  82
# cyan      #2aa198   036  6/6 cyan      37 #00afaf 60 -35 -05  42 161 152 175  74  63
# green     #859900   100  2/2 green     64 #5f8700 60 -20  65 133 153   0  68 100  60

function colour_init() {
    if [[ -z ${no_colour-} ]]; then
        # Text attributes
        readonly ta_bold="$(tput bold 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_uscore="$(tput smul 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_blink="$(tput blink 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_reverse="$(tput rev 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly ta_conceal="$(tput invis 2> /dev/null || true)"
        printf '%b' "$ta_none"

        # Foreground codes
        readonly fg_black="$(tput setaf 16 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_blue="$(tput setaf 32 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_cyan="$(tput setaf 36 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_green="$(tput setaf 100 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_magenta="$(tput setaf 162 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_red="$(tput setaf 160 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_white="$(tput setaf 7 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly fg_yellow="$(tput setaf 136 2> /dev/null || true)"
        printf '%b' "$ta_none"

        # Background codes
        readonly bg_black="$(tput setab 16 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_blue="$(tput setab 102 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_cyan="$(tput setab 109 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_green="$(tput setab 60 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_magenta="$(tput setab 62 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_red="$(tput setab 166 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_white="$(tput setab 230 2> /dev/null || true)"
        printf '%b' "$ta_none"
        readonly bg_yellow="$(tput setab 66 2> /dev/null || true)"
        printf '%b' "$ta_none"
    else
        # Text attributes
        readonly ta_bold=''
        readonly ta_uscore=''
        readonly ta_blink=''
        readonly ta_reverse=''
        readonly ta_conceal=''

        # Foreground codes
        readonly fg_black=''
        readonly fg_blue=''
        readonly fg_cyan=''
        readonly fg_green=''
        readonly fg_magenta=''
        readonly fg_red=''
        readonly fg_white=''
        readonly fg_yellow=''

        # Background codes
        readonly bg_black=''
        readonly bg_blue=''
        readonly bg_cyan=''
        readonly bg_green=''
        readonly bg_magenta=''
        readonly bg_red=''
        readonly bg_white=''
        readonly bg_yellow=''
    fi
}


# DESC: Initialise Cron mode
# ARGS: None
# OUTS: $script_output: Path to the file stdout & stderr was redirected to
function cron_init() {
    if [[ -n ${cron-} ]]; then
        # Redirect all output to a temporary file
        readonly script_output="$(mktemp --tmpdir "$jlenv_name".XXXXX)"
        exec 3>&1 4>&2 1>"$script_output" 2>&1
    fi
}


# DESC: Acquire script lock
# ARGS: $1 (optional): Scope of script execution lock (system or user)
# OUTS: $script_lock: Path to the directory indicating we have the script lock
# NOTE: This lock implementation is extremely simple but should be reliable
#       across all platforms. It does *not* support locking a script with
#       symlinks or multiple hardlinks as there's no portable way of doing so.
#       If the lock was acquired it's automatically released on script exit.
function lock_init() {
    local lock_dir
    if [[ $1 = 'system' ]]; then
        lock_dir="/tmp/$jlenv_name.lock"
    elif [[ $1 = 'user' ]]; then
        lock_dir="/tmp/$jlenv_name.$UID.lock"
    else
        script_exit 'Missing or invalid argument to lock_init()!' 2
    fi

    if mkdir "${lock_dir}" 2> /dev/null; then
        readonly script_lock="$lock_dir"
        verbose_print "Acquired script lock: $script_lock"
    else
        script_exit "Unable to acquire script lock: $lock_dir" 2
    fi
}


# DESC: Pretty print the provided string
# ARGS: $1 (required): Message to print (defaults to a green foreground)
#       $2 (optional): Colour to print the message with. This can be an ANSI
#                      escape code or one of the prepopulated colour variables.
#       $3 (optional): Set to any value to not append a new line to the message
# OUTS: None
function pretty_print() {
    if [[ $# -lt 1 ]]; then
        script_exit 'Missing required argument to pretty_print()!' 2
    fi

    if [[ -z ${no_colour-} ]]; then
        if [[ -n ${2-} ]]; then
            printf '%b' "$2"
        else
            printf '%b' "$fg_green"
        fi
    fi

    # Print message & reset text attributes
    if [[ -n ${3-} ]]; then
        printf 'jlenv:  %s%b' "$1" "$ta_none"
    else
        printf 'jlenv:  %s%b\n' "$1" "$ta_none"
    fi
}


# DESC: Only pretty_print() the provided string if verbose mode is enabled
# ARGS: $@ (required): Passed through to pretty_print() function
# OUTS: None
function verbose_print() {
    if [[ -n ${verbose-} ]]; then
        pretty_print "$@"
    fi
}


# DESC: Combines two path variables and removes any duplicates
# ARGS: $1 (required): Path(s) to join with the second argument
#       $2 (optional): Path(s) to join with the first argument
# OUTS: $build_path: The constructed path
# NOTE: Heavily inspired by: https://unix.stackexchange.com/a/40973
function build_path() {
    if [[ $# -lt 1 ]]; then
        script_exit 'Missing required argument to build_path()!' 2
    fi

    local new_path path_entry temp_path

    temp_path="$1:"
    if [[ -n ${2-} ]]; then
        temp_path="$temp_path$2:"
    fi

    new_path=
    while [[ -n $temp_path ]]; do
        path_entry="${temp_path%%:*}"
        case "$new_path:" in
            *:"$path_entry":*) ;;
                            *) new_path="$new_path:$path_entry"
                               ;;
        esac
        temp_path="${temp_path#*:}"
    done

    # shellcheck disable=SC2034
    build_path="${new_path#:}"
}


# DESC: Check a binary exists in the search path
# ARGS: $1 (required): Name of the binary to test for existence
#       $2 (optional): Set to any value to treat failure as a fatal error
# OUTS: None
function check_binary() {
    if [[ $# -lt 1 ]]; then
        script_exit 'Missing required argument to check_binary()!' 2
    fi

    if ! command -v "$1" > /dev/null 2>&1; then
        if [[ -n ${2-} ]]; then
            script_exit "Missing dependency: Couldn't locate $1." 1
        else
            verbose_print "Missing dependency: $1" "${fg_red-}"
            return 1
        fi
    fi

    verbose_print "Found dependency: $1"
    return 0
}


# DESC: Validate we have superuser access as root (via sudo if requested)
# ARGS: $1 (optional): Set to any value to not attempt root access via sudo
# OUTS: None
function check_superuser() {
    local superuser
    if [[ $EUID -eq 0 ]]; then
        superuser=true
    elif [[ -z ${1-} ]]; then
        if check_binary sudo; then
            verbose_print 'sudo: Updating cached credentials ...'
            if ! sudo -v; then
                verbose_print "sudo: Couldn't acquire credentials ..." \
                              "${fg_red-}"
            else
                local test_euid
                test_euid="$(sudo -H -- "$BASH" -c 'printf "%s" "$EUID"')"
                if [[ $test_euid -eq 0 ]]; then
                    superuser=true
                fi
            fi
        fi
    fi

    if [[ -z ${superuser-} ]]; then
        verbose_print 'Unable to acquire superuser credentials.' "${fg_red-}"
        return 1
    fi

    verbose_print 'Successfully acquired superuser credentials.'
    return 0
}


# DESC: Run the requested command as root (via sudo if requested)
# ARGS: $1 (optional): Set to zero to not attempt execution via sudo
#       $@ (required): Passed through for execution as root user
# OUTS: None
function run_as_root() {
    if [[ $# -eq 0 ]]; then
        script_exit 'Missing required argument to run_as_root()!' 2
    fi

    if [[ ${1-} =~ ^0$ ]]; then
        local skip_sudo
        skip_sudo=true
        shift
    fi

    if [[ $EUID -eq 0 ]]; then
        "$@"
    elif [[ -z ${skip_sudo-} ]]; then
        sudo -H -- "$@"
    else
        script_exit "Unable to run requested command as root: $*" 1
    fi
}

# DESC: Setup the JLENV_DEBUG environment variable.  Default value is no-debug
#       if not already set. Values:
#         1: Debug output
#         0: No-debug output
# ARGS: None.
# OUTS: None.
setup_jlenv_debug() {
  case ${JLENV_DEBUG:-0} in
    0) # Disable tracing
      set +o xtrace          # Do not trace the execution of the script (no-debug)
      ;;
    1) # Enable tracing
      set -o xtrace          # Trace the execution of the script (debug)
      ;;
    *) # Disable tracing
      set +x
      ;;
  esac
}

# DESC: Setup the GNU coreutils readlink
# ARGS: None.
# OUTS: None.
setup_readlink(){
  readonly READLINK=$(type -p greadlink readlink | head -1)
  if [ -z "$READLINK" ]; then
    echo "jlenv: cannot find readlink - are you missing GNU coreutils?" >&2
    exit 1
  fi
}

# DESC: Setup the GNU coreutils realpath
# ARGS: None.
# OUTS: None.
setup_realpath(){
  readonly REALPATH=$(type -p grealpath realpath | head -1)
  if [ -z "$REALPATH" ]; then
    echo "jlenv: cannot find realpath - are you missing GNU coreutils?" >&2
    exit 1
  fi
}

# DESC: Print value of a symbolic link or canonical file name.
#       Canonicalise by following symlinks in components of the given name
#       recursively; all components must exist.
# ARGS: $1 (required): absolute filename
# OUTS: Resolved path of any link to filename
# NOTE: Require GNU coreutils' $(readlink). Does NOT resolve symbolic links.
resolve_link() {
    command -p "${READLINK}" --canonicalize-existing "$1"
  }

# DESC: Print value of a folder or canonical file name.
#       Canonicalise by replacing relative components of the given name 
#       recursively; all components must exist.
# ARGS: $1 (required): absolute filename
# OUTS: Resolved path of any link to filename
# NOTE: Require GNU coreutils' $(readlink).
resolve_path() {
    command -p "${REALPATH}" --no-symlinks --canonicalize-existing "$1"
  }

# DESC: Setup the JLENV_ROOT environment variable.  Default value is set if not
#       already set.
# ARGS: None.
# OUTS: None.
setup_jlenv_root() {
  # test if the variable is set and non-empty
  if [[ "${JLENV_ROOT:-setdefault}" = "setdefault" ]]; then
    JLENV_ROOT="${HOME}/.jlenv"
  else
    JLENV_ROOT="${JLENV_ROOT%/}"
  fi
  export JLENV_ROOT
}

# DESC: Setup the JLENV_DIR environment variable.
# ARGS: None.
# OUTS: None.
setup_jlenv_dir() {
  # test if the variable is set and non-empty
  if [ "${JLENV_DIR:-setdefault}" = "setdefault" ]; then
    JLENV_DIR="$PWD"
  else
    cd "${JLENV_DIR}" 2>/dev/null || script_exit "Cannot change working directory to \$(${JLENV_DIR})" 1
    JLENV_DIR="$PWD"
    cd "$OLDPWD"
  fi
  export JLENV_DIR
}

# DESC: Setup the PATH environment variable.
# ARGS: None.
# OUTS: None.
setup_path() {
  for plugin_bin in "${JLENV_ROOT}/plugins/"*/bin; do
    PATH="${plugin_bin}:${PATH}"
  done
  export PATH="${jlenv_dirname}:${PATH}"
}

# DESC: Setup the JLENV_HOOK_PATH environment variable.
# ARGS: None.
# OUTS: None.
setup_jlenv_hook_path() {
  JLENV_HOOK_PATH="${JLENV_HOOK_PATH:-}:${JLENV_ROOT}/jlenv.d"
  if [ "${jlenv_dirname%/*}" != "$JLENV_ROOT" ]; then
    # Add jlenv's own `jlenv.d` unless jlenv was cloned to JLENV_ROOT
    JLENV_HOOK_PATH="${JLENV_HOOK_PATH}:${jlenv_dirname%/*}/jlenv.d"
  fi
  JLENV_HOOK_PATH="${JLENV_HOOK_PATH}:/usr/local/etc/jlenv.d:/etc/jlenv.d:/usr/lib/jlenv/hooks"
  for plugin_hook in "${JLENV_ROOT}/plugins/"*/etc/jlenv.d; do
    JLENV_HOOK_PATH="${JLENV_HOOK_PATH}:${plugin_hook}"
  done
  JLENV_HOOK_PATH="${JLENV_HOOK_PATH#:}"
  export JLENV_HOOK_PATH
}

# DESC: Setup debug/verbose output.
# ARGS: None.
# OUTS: None.
verbose_setup() {
  verbose=true
  export JLENV_DEBUG=1
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -o xtrace          # Trace the execution of the script (debug)
}

#####################################################################
###  Execute
#####################################################################

# Each time this script is sourced it sets environment variables
# This is akin to a function script_defaults()
setup_jlenv_debug
setup_readlink
setup_realpath
script_init "$@"
setup_jlenv_root
setup_jlenv_dir
shopt -s nullglob
setup_path
setup_jlenv_hook_path
shopt -u nullglob

# vim: syntax=sh cc=80 tw=79 ts=4 sw=4 sts=4 et sr