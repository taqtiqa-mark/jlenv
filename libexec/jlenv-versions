#!/usr/bin/env bash
# Summary: List all Julia versions available to jlenv
# Usage: jlenv versions [--bare] [--skip-aliases]
#
# Lists all Julia versions found in `$JLENV_ROOT/versions/*'.

set -e
[ -n "$JLENV_DEBUG" ] && set -x

unset bare
unset skip_aliases

# DESC: Setup the GNU coreutils readlink
# ARGS: None.
# OUTS: None.
setup_readlink(){
  readonly READLINK=$(type -p greadlink readlink | head -1)
  # We don't test here since jlenv has done so.
}

# DESC: Print value of a symbolic link or canonical file name.
#       Canonicalise by following every symlink in every component
#       of the given name recursively; all but the last component
#       must exist.
# ARGS: $1 (required): absolute filename
# OUTS: Resolved path of any link to filename
# NOTE: Require GNU coreutils' $(readlink).
resolve_link() {
    $READLINK --canonicalize "$1"
}

# DESC: Absolute directory/filename path from relative path/filename.
# ARGS: $1 (required): relative directory/filename
# OUTS: Absolute directory/filename
# NOTE: Does not require GNU coreutils' $(readlink) or $(realpath).
#       Usage examples, assume folder is: /parent/cur
#       abs_dir_file file.txt              => /parent/cur
#       abs_dir_file .                     => /parent/cur
#       abs_dir_file ..                    => /parent
#       abs_dir_file ../dir/file.txt       => /parent/dir
#       abs_dir_file /dir/../dir2/file.txt => /parent/dir2
#       abs_dir_file ../dir/../dir2        => /parent/dir2          # anything cd can handle
#       abs_dir_file doesnotexist          =>                       # empty result if file/dir does not exist
#       abs_dir_file /file.txt             => /                     # handle absolute path input
# REFS: 
#       https://stackoverflow.com/a/21951256/152860
#       https://stackoverflow.com/a/7577209/152860
#       https://stackoverflow.com/a/15780028/152860
#       https://stackoverflow.com/a/23002317/152860
abs_dir_file(){
  local thePath
  declare -a outp
  if [[ ! "$1" =~ ^/ ]];then
    thePath="$PWD/$1"
  else
    thePath="$1"
  fi
  # Parse the path.  Result is possibly a file name.
  fn=$(
      echo "$thePath"|(
      IFS=/
      read -a parr
      for i in "${parr[@]}";do
        case "$i" in
        ''|.) continue ;;
        ..)
          len=$(count_array "${outp[@]+"${outp[@]}"}")
          if ((len==0));then
            continue
          else
            unset -v "outp[ $((len-1)) ]"
          fi
          ;;
        *)
          # Undefined variable error workaround for:
          # len=${#outp[@]}
          #
          # 1. https://stackoverflow.com/a/7577209/152860
          # Use ${outp[@]+"${outp[@]}"} instead of "${outp[@]}"
          len=$(count_array "${outp[@]+"${outp[@]}"}")
          outp[$len]="$i"
          ;;
        esac
      done
      echo /"${outp[*]}"
    )
  )
  echo "${fn}"
}

# https://stackoverflow.com/a/15780028/152860
count_array() { echo $# ; };

# DESC: Absolute directory from resolved absolute filename or relative folder.
# ARGS: $1 (required): resolved absolute filename, or relative folder
# OUTS: Absolute path.
# NOTE: Does not require GNU coreutils' $(readlink) or $(realpath).
#       Usage examples, assume inside /parent/cur
#       abs_dirname file.txt              => /parent/cur
#       abs_dirname .                     => /parent/cur
#       abs_dirname ..                    => /parent
#       abs_dirname ../dir/file.txt       => /parent/dir
#       abs_dirname /dir/../dir2/file.txt => /parent/dir2
#       abs_dirname ../dir/../dir2        => /parent/dir2          # anything cd can handle
#       abs_dirname doesnotexist          =>                       # empty result if file/dir does not exist
#       abs_dirname /file.txt             => /                     # handle absolute path input
# REFS: 
#       https://stackoverflow.com/a/21951256/152860
#       https://stackoverflow.com/a/7577209/152860
#       https://stackoverflow.com/a/15780028/152860
#       https://stackoverflow.com/a/23002317/152860

abs_dirname() {
  if [ -f "${1}" ] 
  then
    # file
    echo "$(cd -P -e "$(dirname "${1}")"; pwd -P)"
  else
    # folder
    echo "$(cd -P -e "${1}"; pwd -P)"
  fi
}


# Provide jlenv completions
for arg; do
  case "$arg" in
  --complete )
    echo --bare
    echo --skip-aliases
    exit ;;
  --bare ) bare=1 ;;
  --skip-aliases ) skip_aliases=1 ;;
  * )
    jlenv-help --usage versions >&2
    exit 1
    ;;
  esac
done

versions_dir="${JLENV_ROOT}/versions"

if [ -d "$versions_dir" ]; then
  versions_dir="$(abs_dirname "$versions_dir")"
fi

if [ -n "$bare" ]; then
  hit_prefix=""
  miss_prefix=""
  current_version=""
  include_system=""
else
  hit_prefix="* "
  miss_prefix="  "
  current_version="$(jlenv-version-name || true)"
  include_system="1"
fi

num_versions=0

print_version() {
  if [ "$1" == "$current_version" ]; then
    echo "${hit_prefix}$(jlenv-version 2>/dev/null)"
  else
    echo "${miss_prefix}$1"
  fi
  num_versions=$((num_versions + 1))
}

# Include "system" in the non-bare output, if it exists
if [ -n "$include_system" ] && JLENV_VERSION=system jlenv-which julia >/dev/null 2>&1; then
  print_version system
fi

shopt -s nullglob
for path in "$versions_dir"/*; do
  if [ -d "$path" ]; then
    if [ -n "$skip_aliases" ] && [ -L "$path" ]; then
      target="$(abs_dirname "$path")"
      [ "${target%/*}" != "$versions_dir" ] || continue
    fi
    print_version "${path##*/}"
  fi
done
shopt -u nullglob

if [ "$num_versions" -eq 0 ] && [ -n "$include_system" ]; then
  echo "Warning: no Julia detected on the system" >&2
  exit 1
fi
